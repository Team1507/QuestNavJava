// Code generated by protocol buffer compiler. Do not edit!
package frc.robot.generated;

import edu.wpi.first.math.proto.Geometry3D;
import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoEnum;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;
import us.hebi.quickbuf.Utf8String;

public final class Commands {
    private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(7719,
        "Cg5jb21tYW5kcy5wcm90bxIYcXVlc3RuYXYucHJvdG9zLmNvbW1hbmRzGhBnZW9tZXRyeTNkLnByb3Rv" + 
        "Il4KIFByb3RvYnVmUXVlc3ROYXZQb3NlUmVzZXRQYXlsb2FkEjoKC3RhcmdldF9wb3NlGAEgASgLMhku" + 
        "d3BpLnByb3RvLlByb3RvYnVmUG9zZTNkUgp0YXJnZXRQb3NlIvIBChdQcm90b2J1ZlF1ZXN0TmF2Q29t" + 
        "bWFuZBJBCgR0eXBlGAEgASgOMi0ucXVlc3RuYXYucHJvdG9zLmNvbW1hbmRzLlF1ZXN0TmF2Q29tbWFu" + 
        "ZFR5cGVSBHR5cGUSHQoKY29tbWFuZF9pZBgCIAEoDVIJY29tbWFuZElkEmoKEnBvc2VfcmVzZXRfcGF5" + 
        "bG9hZBgKIAEoCzI6LnF1ZXN0bmF2LnByb3Rvcy5jb21tYW5kcy5Qcm90b2J1ZlF1ZXN0TmF2UG9zZVJl" + 
        "c2V0UGF5bG9hZEgAUhBwb3NlUmVzZXRQYXlsb2FkQgkKB3BheWxvYWQifwofUHJvdG9idWZRdWVzdE5h" + 
        "dkNvbW1hbmRSZXNwb25zZRIdCgpjb21tYW5kX2lkGAEgASgNUgljb21tYW5kSWQSGAoHc3VjY2VzcxgC" + 
        "IAEoCFIHc3VjY2VzcxIjCg1lcnJvcl9tZXNzYWdlGAMgASgJUgxlcnJvck1lc3NhZ2UqQwoTUXVlc3RO" + 
        "YXZDb21tYW5kVHlwZRIcChhDT01NQU5EX1RZUEVfVU5TUEVDSUZJRUQQABIOCgpQT1NFX1JFU0VUEAFC" + 
        "QwolZ2cucXVlc3RuYXYucXVlc3RuYXYucHJvdG9zLmdlbmVyYXRlZKoCGVF1ZXN0TmF2LlByb3Rvcy5H" + 
        "ZW5lcmF0ZWRKgDcKBxIFAAPVAQEKCAoBDBIDAAMVCvUFCgECEgMWACEy6gUKIFF1ZXN0TmF2IENvbW1h" + 
        "bmRzIFByb3RvY29sIEJ1ZmZlciBEZWZpbml0aW9ucwogCiBUaGlzIGZpbGUgZGVmaW5lcyB0aGUgY29t" + 
        "bWFuZCBzeXN0ZW0gZm9yIFF1ZXN0TmF2LCB3aGljaCBhbGxvd3MgZXh0ZXJuYWwgc3lzdGVtcwogKHN1" + 
        "Y2ggYXMgcm9ib3QgY29kZSkgdG8gc2VuZCBjb21tYW5kcyB0byB0aGUgUXVlc3QgaGVhZHNldCBmb3Ig" + 
        "dmFyaW91cyBvcGVyYXRpb25zLgogVGhlIGNvbW1hbmQgc3lzdGVtIGlzIGRlc2lnbmVkIHRvIGJlIGV4" + 
        "dGVuc2libGUsIGFsbG93aW5nIG5ldyBjb21tYW5kIHR5cGVzIHRvIGJlCiBhZGRlZCB3aXRob3V0IGJy" + 
        "ZWFraW5nIGV4aXN0aW5nIGltcGxlbWVudGF0aW9ucy4KIAogS2V5IEZlYXR1cmVzOgogLSBBc3luY2hy" + 
        "b25vdXMgY29tbWFuZCBleGVjdXRpb24gd2l0aCByZXNwb25zZSB0cmFja2luZwogLSBFeHRlbnNpYmxl" + 
        "IGNvbW1hbmQgdHlwZSBzeXN0ZW0KIC0gVHlwZS1zYWZlIHBheWxvYWQgc3lzdGVtIHVzaW5nIG9uZW9m",
        "CiAtIEVycm9yIGhhbmRsaW5nIGFuZCBzdGF0dXMgcmVwb3J0aW5nCiAKIFVzYWdlIEZsb3c6CiAxLiBD" + 
        "bGllbnQgc2VuZHMgUHJvdG9idWZRdWVzdE5hdkNvbW1hbmQgd2l0aCB1bmlxdWUgY29tbWFuZF9pZAog" + 
        "Mi4gUXVlc3ROYXYgcHJvY2Vzc2VzIHRoZSBjb21tYW5kIGFzeW5jaHJvbm91c2x5CiAzLiBRdWVzdE5h" + 
        "diBzZW5kcyBiYWNrIFByb3RvYnVmUXVlc3ROYXZDb21tYW5kUmVzcG9uc2Ugd2l0aCBtYXRjaGluZyBj" + 
        "b21tYW5kX2lkCgoICgEIEgMXADYKCQoCCCUSAxcANgoICgEIEgMYAD4KCQoCCAESAxgAPgo/CgIDABID" + 
        "GwAaGjQgSW1wb3J0IGdlb21ldHJ5IG1lc3NhZ2VzIGZvciBwb3NlLXJlbGF0ZWQgY29tbWFuZHMKCs8D" + 
        "CgIFABIEKQA7ARrCAwogRW51bWVyYXRpb24gb2YgYXZhaWxhYmxlIGNvbW1hbmQgdHlwZXMgaW4gdGhl" + 
        "IFF1ZXN0TmF2IHN5c3RlbS4KIAogVGhpcyBlbnVtIGRlZmluZXMgYWxsIHRoZSBkaWZmZXJlbnQgdHlw" + 
        "ZXMgb2YgY29tbWFuZHMgdGhhdCBjYW4gYmUgc2VudCB0bwogdGhlIFF1ZXN0IGhlYWRzZXQuIFRoZSBl" + 
        "bnVtIGlzIGRlc2lnbmVkIHRvIGJlIGV4dGVuc2libGUgLSBuZXcgY29tbWFuZCB0eXBlcwogY2FuIGJl" + 
        "IGFkZGVkIHdpdGhvdXQgYnJlYWtpbmcgZXhpc3RpbmcgY2xpZW50cy4KIAogRGVzaWduIE5vdGVzOgog" + 
        "LSBWYWx1ZXMgc3RhcnQgZnJvbSAwIGFzIHJlcXVpcmVkIGJ5IHByb3RvMwogLSBVTlNQRUNJRklFRCB2" + 
        "YWx1ZSAoMCkgaXMgcmVzZXJ2ZWQgZm9yIGVycm9yIGhhbmRsaW5nCiAtIENvbW1hbmQgdmFsdWVzIHNo" + 
        "b3VsZCBiZSBhc3NpZ25lZCBpbmNyZW1lbnRhbGx5IGZvciBjbGFyaXR5CgoKCgMFAAESAykFGApACgQF" + 
        "AAIAEgMqAh8iMyBEZWZhdWx0L2ludmFsaWQgY29tbWFuZCB0eXBlIChyZXF1aXJlZCBieSBwcm90bzMp" + 
        "CgoMCgUFAAIAARIDKgIaCgwKBQUAAgACEgMqHR4K1gIKBAUAAgESAzUCERrIAgogUE9TRV9SRVNFVDog" + 
        "UmVzZXRzIHRoZSByb2JvdCdzIHBvc2UgZXN0aW1hdGlvbiB0byBhIHNwZWNpZmllZCB0YXJnZXQgcG9z" + 
        "ZS4KIAogVGhpcyBjb21tYW5kIGlzIHVzZWQgdG8gY29ycmVjdCBkcmlmdCBpbiB0aGUgdHJhY2tpbmcg" + 
        "c3lzdGVtIGJ5IHNldHRpbmcKIHRoZSByb2JvdCdzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiB0byBr" + 
        "bm93biB2YWx1ZXMuIFR5cGljYWxseSB1c2VkIHdoZW4KIHRoZSByb2JvdCBpcyBwbGFjZWQgYXQgYSBr",
        "bm93biBsb2NhdGlvbiBvbiB0aGUgZmllbGQuCiAKIFJlcXVpcmVzOiBQcm90b2J1ZlF1ZXN0TmF2UG9z" + 
        "ZVJlc2V0UGF5bG9hZAoKDAoFBQACAQESAzUCDAoMCgUFAAIBAhIDNQ8QCqsGCgIEABIETwBcARqeBgog" + 
        "UGF5bG9hZCBtZXNzYWdlIGZvciB0aGUgUE9TRV9SRVNFVCBjb21tYW5kLgogCiBUaGlzIG1lc3NhZ2Ug" + 
        "Y29udGFpbnMgdGhlIGRhdGEgbmVlZGVkIHRvIGV4ZWN1dGUgYSBwb3NlIHJlc2V0IG9wZXJhdGlvbi4K" + 
        "IFRoZSBwb3NlIHJlc2V0IGNvbW1hbmQgYWxsb3dzIGV4dGVybmFsIHN5c3RlbXMgdG8gY29ycmVjdCB0" + 
        "aGUgUXVlc3QncwogdW5kZXJzdGFuZGluZyBvZiB0aGUgcm9ib3QncyBwb3NpdGlvbiBhbmQgb3JpZW50" + 
        "YXRpb24gb24gdGhlIGZpZWxkLgogCiBDb29yZGluYXRlIFN5c3RlbToKIC0gVXNlcyBXUElMaWIgZmll" + 
        "bGQtcmVsYXRpdmUgY29vcmRpbmF0ZSBzeXN0ZW0KIC0gWC1heGlzOiBGb3J3YXJkICh0b3dhcmRzIG9w" + 
        "cG9zaW5nIGFsbGlhbmNlKQogLSBZLWF4aXM6IExlZnQgKHdoZW4gZmFjaW5nIGZvcndhcmQpCiAtIFot" + 
        "YXhpczogVXAKIC0gWWF3IChaKTogQ291bnRlci1jbG9ja3dpc2UgKHJpZ2h0LWhhbmRlZCkgcm90YXRp" + 
        "b24gYXJvdW5kIHRoZSBaIGF4aXMKIC0gUGl0Y2ggKFkpOiBDb3VudGVyLWNsb2Nrd2lzZSAocmlnaHQt" + 
        "aGFuZGVkKSByb3RhdGlvbiBhcm91bmQgWSBheGlzCiAtIFJvbGwgKFgpOiBDb3VudGVyLWNsb2Nrd2lz" + 
        "ZSAocmlnaHQtaGFuZGVkKSByb3RhdGlvbiBhcm91bmQgdGhlIFggYXhpcwogLSBSb3RhdGlvbjogQ291" + 
        "bnRlci1jbG9ja3dpc2UgcG9zaXRpdmUgKHJpZ2h0LWhhbmQgY29vcmRpbmF0ZSBzeXN0ZW0pCiAtIE9y" + 
        "aWdpbjogVHlwaWNhbGx5IGF0IG9uZSBjb3JuZXIgb2YgdGhlIGZpZWxkIChzZWUgZmllbGQgbGF5b3V0" + 
        "IGRvY3VtZW50YXRpb24pCgoKCgMEAAESA08IKArQAgoEBAACABIDWwIrGsICCiBUaGUgdGFyZ2V0IHBv" + 
        "c2UgdG8gcmVzZXQgdGhlIHJvYm90IHRvLgogCiBUaGlzIHNob3VsZCByZXByZXNlbnQgdGhlIHJvYm90" + 
        "J3MgYWN0dWFsIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvbiB0aGUgZmllbGQKIGluIHRoZSBXUElM" + 
        "aWIgY29vcmRpbmF0ZSBzeXN0ZW0uIFRoZSBRdWVzdCB3aWxsIHVwZGF0ZSBpdHMgaW50ZXJuYWwgdHJh" + 
        "Y2tpbmcKIHRvIG1hdGNoIHRoaXMgcG9zZSwgZWZmZWN0aXZlbHkgY29ycmVjdGluZyBhbnkgYWNjdW11",
        "bGF0ZWQgZHJpZnQuCiAKIFVuaXRzOgogLSBUcmFuc2xhdGlvbjogbWV0ZXJzCiAtIFJvdGF0aW9uOiBy" + 
        "YWRpYW5zCgoMCgUEAAIABhIDWwIaCgwKBQQAAgABEgNbGyYKDAoFBAACAAMSA1spKgqnBQoCBAESBW4A" + 
        "nAEBGpkFCiBNYWluIGNvbW1hbmQgbWVzc2FnZSBzZW50IHRvIHRoZSBRdWVzdE5hdiBzeXN0ZW0uCiAK" + 
        "IFRoaXMgaXMgdGhlIHByaW1hcnkgbWVzc2FnZSB0eXBlIHVzZWQgdG8gc2VuZCBjb21tYW5kcyBmcm9t" + 
        "IGV4dGVybmFsIHN5c3RlbXMKIChsaWtlIHJvYm90IGNvZGUpIHRvIHRoZSBRdWVzdCBoZWFkc2V0LiBF" + 
        "YWNoIGNvbW1hbmQgaW5jbHVkZXMgYSB0eXBlIGlkZW50aWZpZXIsCiBhIHVuaXF1ZSB0cmFja2luZyBJ" + 
        "RCwgYW5kIG9wdGlvbmFsIHBheWxvYWQgZGF0YSBzcGVjaWZpYyB0byB0aGUgY29tbWFuZCB0eXBlLgog" + 
        "CiBUaGUgY29tbWFuZCBzeXN0ZW0gaXMgZGVzaWduZWQgZm9yIGFzeW5jaHJvbm91cyBvcGVyYXRpb24g" + 
        "LSBjb21tYW5kcyBhcmUgc2VudAogYW5kIHJlc3BvbnNlcyBhcmUgcmVjZWl2ZWQgc2VwYXJhdGVseSwg" + 
        "bWF0Y2hlZCBieSB0aGUgY29tbWFuZF9pZCBmaWVsZC4KIAogTWVzc2FnZSBGbG93OgogMS4gQ2xpZW50" + 
        "IGNyZWF0ZXMgY29tbWFuZCB3aXRoIHVuaXF1ZSBjb21tYW5kX2lkCiAyLiBDbGllbnQgc2V0cyBhcHBy" + 
        "b3ByaWF0ZSB0eXBlIGFuZCBwYXlsb2FkCiAzLiBDbGllbnQgc2VuZHMgY29tbWFuZCB0byBRdWVzdAog" + 
        "NC4gUXVlc3QgcHJvY2Vzc2VzIGNvbW1hbmQgYW5kIHNlbmRzIHJlc3BvbnNlIHdpdGggbWF0Y2hpbmcg" + 
        "Y29tbWFuZF9pZAoKCgoDBAEBEgNuCB8K3gEKBAQBAgASA3YCHxrQAQogVGhlIHR5cGUgb2YgY29tbWFu" + 
        "ZCBiZWluZyBzZW50LgogCiBUaGlzIGZpZWxkIGRldGVybWluZXMgd2hpY2ggcGF5bG9hZCAoaWYgYW55" + 
        "KSBzaG91bGQgYmUgcG9wdWxhdGVkIGFuZAogaG93IHRoZSBRdWVzdCBzaG91bGQgcHJvY2VzcyB0aGUg" + 
        "Y29tbWFuZC4gU2VlIFF1ZXN0TmF2Q29tbWFuZFR5cGUKIGVudW0gZm9yIGF2YWlsYWJsZSBjb21tYW5k" + 
        "IHR5cGVzLgoKDAoFBAECAAYSA3YCFQoMCgUEAQIAARIDdhYaCgwKBQQBAgADEgN2HR4KrwMKBAQBAgES" + 
        "BIMBAhgaoAMKIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGNvbW1hbmQgaW5zdGFuY2UuCiAKIFRo" + 
        "aXMgSUQgaXMgdXNlZCB0byBtYXRjaCBjb21tYW5kcyB3aXRoIHRoZWlyIHJlc3BvbnNlcyBpbiBhc3lu",
        "Y2hyb25vdXMKIGNvbW11bmljYXRpb24uIFRoZSBjbGllbnQgc2hvdWxkIGdlbmVyYXRlIHVuaXF1ZSBJ" + 
        "RHMgZm9yIGVhY2ggY29tbWFuZAogdG8gYXZvaWQgY29uZnVzaW9uLiBUaGUgUXVlc3Qgd2lsbCBlY2hv" + 
        "IHRoaXMgSUQgaW4gdGhlIHJlc3BvbnNlIG1lc3NhZ2UuCiAKIFJlY29tbWVuZGVkOiBVc2UgaW5jcmVt" + 
        "ZW50aW5nIGludGVnZXJzIG9yIHRpbWVzdGFtcHMgZm9yIHVuaXF1ZW5lc3MuCiAKIE5vdGU6IEZvciBG" + 
        "UkMgdXNlcnMsIHRoZSB2ZW5kb3IgZGVwZW5kZW5jeSB3aWxsIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2Fs" + 
        "bHkuCgoNCgUEAQIBBRIEgwECCAoNCgUEAQIBARIEgwEJEwoNCgUEAQIBAxIEgwEWFwrYAgoEBAEIABIG" + 
        "jgECmwEDGscCCiBDb21tYW5kLXNwZWNpZmljIHBheWxvYWQgZGF0YS4KIAogVGhpcyBvbmVvZiBmaWVs" + 
        "ZCBjb250YWlucyB0aGUgc3BlY2lmaWMgZGF0YSBuZWVkZWQgZm9yIGVhY2ggY29tbWFuZCB0eXBlLgog" + 
        "T25seSBvbmUgcGF5bG9hZCBmaWVsZCB3aWxsIGJlIHNldCwgY29ycmVzcG9uZGluZyB0byB0aGUgY29t" + 
        "bWFuZCB0eXBlLgogQ29tbWFuZHMgdGhhdCBkb24ndCByZXF1aXJlIGFkZGl0aW9uYWwgZGF0YSBkb24n" + 
        "dCBuZWVkIGEgcGF5bG9hZCBlbnRyeS4KIAogRmllbGQgbnVtYmVyaW5nIHN0YXJ0cyBhdCAxMCB0byBs" + 
        "ZWF2ZSByb29tIGZvciBmdXR1cmUgY29tbW9uIGZpZWxkcy4KCg0KBQQBCAABEgSOAQgPClkKBAQBAgIS" + 
        "BJMBBD0aSwogUGF5bG9hZCBmb3IgUE9TRV9SRVNFVCBjb21tYW5kcy4KIFNldCB0aGlzIGZpZWxkIHdo" + 
        "ZW4gdHlwZSA9IFBPU0VfUkVTRVQuCgoNCgUEAQICBhIEkwEEJAoNCgUEAQICARIEkwElNwoNCgUEAQIC" + 
        "AxIEkwE6PAqSBgoCBAISBrABANUBARqDBgogUmVzcG9uc2UgbWVzc2FnZSBzZW50IGJhY2sgYWZ0ZXIg" + 
        "cHJvY2Vzc2luZyBhIGNvbW1hbmQuCiAKIFRoaXMgbWVzc2FnZSBpcyBzZW50IGJ5IHRoZSBRdWVzdCBi" + 
        "YWNrIHRvIHRoZSBjbGllbnQgYWZ0ZXIgcHJvY2Vzc2luZwogYSBQcm90b2J1ZlF1ZXN0TmF2Q29tbWFu" + 
        "ZC4gSXQgcHJvdmlkZXMgc3RhdHVzIGluZm9ybWF0aW9uIGFib3V0IHdoZXRoZXIKIHRoZSBjb21tYW5k" + 
        "IHdhcyBleGVjdXRlZCBzdWNjZXNzZnVsbHkgYW5kIGFueSBlcnJvciBkZXRhaWxzIGlmIGl0IGZhaWxl" + 
        "ZC4KIAogVGhlIHJlc3BvbnNlIGlzIG1hdGNoZWQgdG8gdGhlIG9yaWdpbmFsIGNvbW1hbmQgdXNpbmcg",
        "dGhlIGNvbW1hbmRfaWQgZmllbGQsCiBhbGxvd2luZyBmb3IgcHJvcGVyIGFzeW5jaHJvbm91cyBjb21t" + 
        "YW5kIGhhbmRsaW5nIGV2ZW4gd2hlbiBtdWx0aXBsZQogY29tbWFuZHMgYXJlIGluIGZsaWdodCBzaW11" + 
        "bHRhbmVvdXNseS4KIAogUmVzcG9uc2UgVGltaW5nOgogLSBSZXNwb25zZXMgYXJlIHNlbnQgYWZ0ZXIg" + 
        "Y29tbWFuZCBwcm9jZXNzaW5nIGNvbXBsZXRlcwogLSBTb21lIGNvbW1hbmRzIG1heSB0YWtlIHRpbWUg" + 
        "dG8gZXhlY3V0ZSAoZS5nLiwgcG9zZSByZXNldCB3aXRoIHZhbGlkYXRpb24pCiAtIENsaWVudHMgc2hv" + 
        "dWxkIGltcGxlbWVudCB0aW1lb3V0cyBmb3IgY29tbWFuZCByZXNwb25zZXMKIAogTm90ZTogRm9yIEZS" + 
        "QyB1c2VycywgdGhlIHZlbmRvciBkZXBlbmRlbmN5IHdpbGwgaGFuZGxlIHJlc3BvbnNlIG1hdGNoaW5n" + 
        "IGF1dG9tYXRpY2FsbHkuCgoLCgMEAgESBLABCCcKkgIKBAQCAgASBLgBAhgagwIKIENvbW1hbmQgSUQg" + 
        "dGhhdCBtYXRjaGVzIHRoZSBvcmlnaW5hbCBjb21tYW5kLgogCiBUaGlzIGZpZWxkIGVjaG9lcyB0aGUg" + 
        "Y29tbWFuZF9pZCBmcm9tIHRoZSBvcmlnaW5hbCBQcm90b2J1ZlF1ZXN0TmF2Q29tbWFuZAogdGhhdCB0" + 
        "aGlzIHJlc3BvbnNlIGNvcnJlc3BvbmRzIHRvLiBDbGllbnRzIHVzZSB0aGlzIHRvIG1hdGNoIHJlc3Bv" + 
        "bnNlcwogd2l0aCB0aGVpciBvcmlnaW5hbCBjb21tYW5kcyBpbiBhc3luY2hyb25vdXMgY29tbXVuaWNh" + 
        "dGlvbi4KCg0KBQQCAgAFEgS4AQIICg0KBQQCAgABEgS4AQkTCg0KBQQCAgADEgS4ARYXCoUDCgQEAgIB" + 
        "EgTEAQITGvYCCiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY29tbWFuZCB3YXMgZXhlY3V0ZWQgc3VjY2Vz" + 
        "c2Z1bGx5LgogCiB0cnVlOiAgQ29tbWFuZCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5CiBmYWxzZTogQ29t" + 
        "bWFuZCBmYWlsZWQgKHNlZSBlcnJvcl9tZXNzYWdlIGZvciBkZXRhaWxzKQogCiBOb3RlOiBBIHN1Y2Nl" + 
        "c3NmdWwgcmVzcG9uc2UgbWVhbnMgdGhlIGNvbW1hbmQgd2FzIHByb2Nlc3NlZCwgYnV0IGRvZXNuJ3QK" + 
        "IG5lY2Vzc2FyaWx5IGd1YXJhbnRlZSB0aGUgZGVzaXJlZCBvdXRjb21lIChlLmcuLCBwb3NlIHJlc2V0" + 
        "IG1pZ2h0IHN1Y2NlZWQKIGJ1dCB0cmFja2luZyBjb3VsZCBzdGlsbCBiZSBwb29yIGR1ZSB0byBlbnZp" + 
        "cm9ubWVudGFsIGNvbmRpdGlvbnMpLgoKDQoFBAICAQUSBMQBAgYKDQoFBAICAQESBMQBBw4KDQoFBAIC",
        "AQMSBMQBERIKxwMKBAQCAgISBNQBAhsauAMKIEh1bWFuLXJlYWRhYmxlIGVycm9yIG1lc3NhZ2Ugd2hl" + 
        "biBzdWNjZXNzID0gZmFsc2UuCiAKIFRoaXMgZmllbGQgcHJvdmlkZXMgZGV0YWlsZWQgaW5mb3JtYXRp" + 
        "b24gYWJvdXQgd2h5IGEgY29tbWFuZCBmYWlsZWQuCiBJdCBzaG91bGQgYmUgZW1wdHkgb3IgaWdub3Jl" + 
        "ZCB3aGVuIHN1Y2Nlc3MgPSB0cnVlLgogCiBFcnJvciBtZXNzYWdlcyBhcmUgaW50ZW5kZWQgZm9yIGRl" + 
        "YnVnZ2luZyBhbmQgbG9nZ2luZyBwdXJwb3Nlcy4KIFRoZXkgbWF5IGluY2x1ZGUgdGVjaG5pY2FsIGRl" + 
        "dGFpbHMgYWJvdXQgdGhlIGZhaWx1cmUgY2F1c2UuCiAKIEV4YW1wbGVzOgogLSAiSW52YWxpZCBwb3Nl" + 
        "IGNvb3JkaW5hdGVzOiB4IHZhbHVlIG91dCBvZiBmaWVsZCBib3VuZHMiCiAtICJUcmFja2luZyBzeXN0" + 
        "ZW0gbm90IGluaXRpYWxpemVkIgogLSAiVW5rbm93biBjb21tYW5kIHR5cGUiCgoNCgUEAgICBRIE1AEC" + 
        "CAoNCgUEAgICARIE1AEJFgoNCgUEAgICAxIE1AEZGmIGcHJvdG8z");

    static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("commands.proto", "questnav.protos.commands", descriptorData, Geometry3D.getDescriptor());

    static final Descriptors.Descriptor questnav_protos_commands_ProtobufQuestNavPoseResetPayload_descriptor = descriptor.internalContainedType(62, 94, "ProtobufQuestNavPoseResetPayload", "questnav.protos.commands.ProtobufQuestNavPoseResetPayload");

    static final Descriptors.Descriptor questnav_protos_commands_ProtobufQuestNavCommand_descriptor = descriptor.internalContainedType(159, 242, "ProtobufQuestNavCommand", "questnav.protos.commands.ProtobufQuestNavCommand");

    static final Descriptors.Descriptor questnav_protos_commands_ProtobufQuestNavCommandResponse_descriptor = descriptor.internalContainedType(403, 127, "ProtobufQuestNavCommandResponse", "questnav.protos.commands.ProtobufQuestNavCommandResponse");

    /**
     * @return this proto file's descriptor.
     */
    public static Descriptors.FileDescriptor getDescriptor() {
        return descriptor;
    }

    /**
     * <pre>
     *
     *  Enumeration of available command types in the QuestNav system.
     *  
     *  This enum defines all the different types of commands that can be sent to
     *  the Quest headset. The enum is designed to be extensible - new command types
     *  can be added without breaking existing clients.
     *  
     *  Design Notes:
     *  - Values start from 0 as required by proto3
     *  - UNSPECIFIED value (0) is reserved for error handling
     *  - Command values should be assigned incrementally for clarity
     * </pre>
     *
     * Protobuf enum {@code QuestNavCommandType}
     */
    public enum QuestNavCommandType implements ProtoEnum<QuestNavCommandType> {
        /**
         * <pre>
         *  Default/invalid command type (required by proto3)
         * </pre>
         *
         * <code>COMMAND_TYPE_UNSPECIFIED = 0;</code>
         */
        COMMAND_TYPE_UNSPECIFIED("COMMAND_TYPE_UNSPECIFIED", 0),

        /**
         * <pre>
         *
         *  POSE_RESET: Resets the robot's pose estimation to a specified target pose.
         *  
         *  This command is used to correct drift in the tracking system by setting
         *  the robot's position and orientation to known values. Typically used when
         *  the robot is placed at a known location on the field.
         *  
         *  Requires: ProtobufQuestNavPoseResetPayload
         * </pre>
         *
         * <code>POSE_RESET = 1;</code>
         */
        POSE_RESET("POSE_RESET", 1);

        /**
         * <pre>
         *  Default/invalid command type (required by proto3)
         * </pre>
         *
         * <code>COMMAND_TYPE_UNSPECIFIED = 0;</code>
         */
        public static final int COMMAND_TYPE_UNSPECIFIED_VALUE = 0;

        /**
         * <pre>
         *
         *  POSE_RESET: Resets the robot's pose estimation to a specified target pose.
         *  
         *  This command is used to correct drift in the tracking system by setting
         *  the robot's position and orientation to known values. Typically used when
         *  the robot is placed at a known location on the field.
         *  
         *  Requires: ProtobufQuestNavPoseResetPayload
         * </pre>
         *
         * <code>POSE_RESET = 1;</code>
         */
        public static final int POSE_RESET_VALUE = 1;

        private final String name;

        private final int number;

        private QuestNavCommandType(String name, int number) {
            this.name = name;
            this.number = number;
        }

        /**
         * @return the string representation of enum entry
         */
        @Override
        public String getName() {
            return name;
        }

        /**
         * @return the numeric wire value of this enum entry
         */
        @Override
        public int getNumber() {
            return number;
        }

        /**
         * @return a converter that maps between this enum's numeric and text representations
         */
        public static ProtoEnum.EnumConverter<QuestNavCommandType> converter() {
            return QuestNavCommandTypeConverter.INSTANCE;
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @return The enum associated with the given numeric wire value, or null if unknown.
         */
        public static QuestNavCommandType forNumber(int value) {
            return QuestNavCommandTypeConverter.INSTANCE.forNumber(value);
        }

        /**
         * @param value The numeric wire value of the corresponding enum entry.
         * @param other Fallback value in case the value is not known.
         * @return The enum associated with the given numeric wire value, or the fallback value if unknown.
         */
        public static QuestNavCommandType forNumberOr(int number, QuestNavCommandType other) {
            QuestNavCommandType value = forNumber(number);
            return value == null ? other : value;
        }

        enum QuestNavCommandTypeConverter implements ProtoEnum.EnumConverter<QuestNavCommandType> {
            INSTANCE;

            private static final QuestNavCommandType[] lookup = new QuestNavCommandType[2];

            static {
                lookup[0] = COMMAND_TYPE_UNSPECIFIED;
                lookup[1] = POSE_RESET;
            }

            @Override
            public final QuestNavCommandType forNumber(final int value) {
                if (value >= 0 && value < lookup.length) {
                    return lookup[value];
                }
                return null;
            }

            @Override
            public final QuestNavCommandType forName(final CharSequence value) {
                if (value.length() == 10) {
                    if (ProtoUtil.isEqual("POSE_RESET", value)) {
                        return POSE_RESET;
                    }
                }
                if (value.length() == 24) {
                    if (ProtoUtil.isEqual("COMMAND_TYPE_UNSPECIFIED", value)) {
                        return COMMAND_TYPE_UNSPECIFIED;
                    }
                }
                return null;
            }
        }
    }

    /**
     * <pre>
     *
     *  Payload message for the POSE_RESET command.
     *  
     *  This message contains the data needed to execute a pose reset operation.
     *  The pose reset command allows external systems to correct the Quest's
     *  understanding of the robot's position and orientation on the field.
     *  
     *  Coordinate System:
     *  - Uses WPILib field-relative coordinate system
     *  - X-axis: Forward (towards opposing alliance)
     *  - Y-axis: Left (when facing forward)
     *  - Z-axis: Up
     *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
     *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
     *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
     *  - Rotation: Counter-clockwise positive (right-hand coordinate system)
     *  - Origin: Typically at one corner of the field (see field layout documentation)
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavPoseResetPayload}
     */
    public static final class ProtobufQuestNavPoseResetPayload extends ProtoMessage<ProtobufQuestNavPoseResetPayload> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d target_pose = 1;</code>
         */
        private final Geometry3D.ProtobufPose3d targetPose = Geometry3D.ProtobufPose3d.newInstance();

        private ProtobufQuestNavPoseResetPayload() {
        }

        /**
         * <pre>
         *
         *  Payload message for the POSE_RESET command.
         *  
         *  This message contains the data needed to execute a pose reset operation.
         *  The pose reset command allows external systems to correct the Quest's
         *  understanding of the robot's position and orientation on the field.
         *  
         *  Coordinate System:
         *  - Uses WPILib field-relative coordinate system
         *  - X-axis: Forward (towards opposing alliance)
         *  - Y-axis: Left (when facing forward)
         *  - Z-axis: Up
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Rotation: Counter-clockwise positive (right-hand coordinate system)
         *  - Origin: Typically at one corner of the field (see field layout documentation)
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavPoseResetPayload}
         */
        public static ProtobufQuestNavPoseResetPayload newInstance() {
            return new ProtobufQuestNavPoseResetPayload();
        }

        /**
         * <pre>
         *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d target_pose = 1;</code>
         * @return whether the targetPose field is set
         */
        public boolean hasTargetPose() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d target_pose = 1;</code>
         * @return this
         */
        public ProtobufQuestNavPoseResetPayload clearTargetPose() {
            bitField0_ &= ~0x00000001;
            targetPose.clear();
            return this;
        }

        /**
         * <pre>
         *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d target_pose = 1;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutableTargetPose()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Geometry3D.ProtobufPose3d getTargetPose() {
            return targetPose;
        }

        /**
         * <pre>
         *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d target_pose = 1;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Geometry3D.ProtobufPose3d getMutableTargetPose() {
            bitField0_ |= 0x00000001;
            return targetPose;
        }

        /**
         * <pre>
         *
         *  The target pose to reset the robot to.
         *  
         *  This should represent the robot's actual position and orientation on the field
         *  in the WPILib coordinate system. The Quest will update its internal tracking
         *  to match this pose, effectively correcting any accumulated drift.
         *  
         *  Units:
         *  - Translation: meters
         *  - Rotation: radians
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d target_pose = 1;</code>
         * @param value the targetPose to set
         * @return this
         */
        public ProtobufQuestNavPoseResetPayload setTargetPose(
                final Geometry3D.ProtobufPose3d value) {
            bitField0_ |= 0x00000001;
            targetPose.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload copyFrom(
                final ProtobufQuestNavPoseResetPayload other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                targetPose.copyFrom(other.targetPose);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload mergeFrom(
                final ProtobufQuestNavPoseResetPayload other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTargetPose()) {
                getMutableTargetPose().mergeFrom(other.targetPose);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            targetPose.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            targetPose.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavPoseResetPayload)) {
                return false;
            }
            ProtobufQuestNavPoseResetPayload other = (ProtobufQuestNavPoseResetPayload) o;
            return bitField0_ == other.bitField0_
                && (!hasTargetPose() || targetPose.equals(other.targetPose));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 10);
                output.writeMessageNoTag(targetPose);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(targetPose);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavPoseResetPayload mergeFrom(final ProtoSource input) throws
                IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 10: {
                        // targetPose
                        input.readMessage(targetPose);
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeMessage(FieldNames.targetPose, targetPose);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavPoseResetPayload mergeFrom(final JsonSource input) throws
                IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case 486493634:
                    case -2084687233: {
                        if (input.isAtField(FieldNames.targetPose)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(targetPose);
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavPoseResetPayload clone() {
            return new ProtobufQuestNavPoseResetPayload().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavPoseResetPayload parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavPoseResetPayload(), data).checkInitialized();
        }

        public static ProtobufQuestNavPoseResetPayload parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavPoseResetPayload(), input).checkInitialized();
        }

        public static ProtobufQuestNavPoseResetPayload parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavPoseResetPayload(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavPoseResetPayload messages
         */
        public static MessageFactory<ProtobufQuestNavPoseResetPayload> getFactory() {
            return ProtobufQuestNavPoseResetPayloadFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_ProtobufQuestNavPoseResetPayload_descriptor;
        }

        private enum ProtobufQuestNavPoseResetPayloadFactory implements MessageFactory<ProtobufQuestNavPoseResetPayload> {
            INSTANCE;

            @Override
            public ProtobufQuestNavPoseResetPayload create() {
                return ProtobufQuestNavPoseResetPayload.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName targetPose = FieldName.forField("targetPose", "target_pose");
        }
    }

    /**
     * <pre>
     *
     *  Main command message sent to the QuestNav system.
     *  
     *  This is the primary message type used to send commands from external systems
     *  (like robot code) to the Quest headset. Each command includes a type identifier,
     *  a unique tracking ID, and optional payload data specific to the command type.
     *  
     *  The command system is designed for asynchronous operation - commands are sent
     *  and responses are received separately, matched by the command_id field.
     *  
     *  Message Flow:
     *  1. Client creates command with unique command_id
     *  2. Client sets appropriate type and payload
     *  3. Client sends command to Quest
     *  4. Quest processes command and sends response with matching command_id
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavCommand}
     */
    public static final class ProtobufQuestNavCommand extends ProtoMessage<ProtobufQuestNavCommand> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         */
        private int commandId;

        /**
         * <pre>
         *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         */
        private int type;

        /**
         * <pre>
         *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         */
        private final ProtobufQuestNavPoseResetPayload poseResetPayload = ProtobufQuestNavPoseResetPayload.newInstance();

        private ProtobufQuestNavCommand() {
        }

        /**
         * <pre>
         *
         *  Main command message sent to the QuestNav system.
         *  
         *  This is the primary message type used to send commands from external systems
         *  (like robot code) to the Quest headset. Each command includes a type identifier,
         *  a unique tracking ID, and optional payload data specific to the command type.
         *  
         *  The command system is designed for asynchronous operation - commands are sent
         *  and responses are received separately, matched by the command_id field.
         *  
         *  Message Flow:
         *  1. Client creates command with unique command_id
         *  2. Client sets appropriate type and payload
         *  3. Client sends command to Quest
         *  4. Quest processes command and sends response with matching command_id
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavCommand}
         */
        public static ProtobufQuestNavCommand newInstance() {
            return new ProtobufQuestNavCommand();
        }

        public boolean hasPayload() {
            return (((bitField0_ & 0x00000001)) != 0);
        }

        public ProtobufQuestNavCommand clearPayload() {
            if (hasPayload()) {
                clearPoseResetPayload();
            }
            return this;
        }

        /**
         * <pre>
         *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return whether the commandId field is set
         */
        public boolean hasCommandId() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return this
         */
        public ProtobufQuestNavCommand clearCommandId() {
            bitField0_ &= ~0x00000002;
            commandId = 0;
            return this;
        }

        /**
         * <pre>
         *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @return the commandId
         */
        public int getCommandId() {
            return commandId;
        }

        /**
         * <pre>
         *
         *  Unique identifier for this command instance.
         *  
         *  This ID is used to match commands with their responses in asynchronous
         *  communication. The client should generate unique IDs for each command
         *  to avoid confusion. The Quest will echo this ID in the response message.
         *  
         *  Recommended: Use incrementing integers or timestamps for uniqueness.
         *  
         *  Note: For FRC users, the vendor dependency will handle this automatically.
         * </pre>
         *
         * <code>optional uint32 command_id = 2;</code>
         * @param value the commandId to set
         * @return this
         */
        public ProtobufQuestNavCommand setCommandId(final int value) {
            bitField0_ |= 0x00000002;
            commandId = value;
            return this;
        }

        /**
         * <pre>
         *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @return whether the type field is set
         */
        public boolean hasType() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @return this
         */
        public ProtobufQuestNavCommand clearType() {
            bitField0_ &= ~0x00000004;
            type = 0;
            return this;
        }

        /**
         * <pre>
         *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @return the type
         */
        public QuestNavCommandType getType() {
            return QuestNavCommandType.forNumber(type);
        }

        /**
         * Gets the value of the internal enum store. The result is
         * equivalent to {@link ProtobufQuestNavCommand#getType()}.getNumber().
         *
         * @return numeric wire representation
         */
        public int getTypeValue() {
            return type;
        }

        /**
         * Sets the value of the internal enum store. This does not
         * do any validity checks, so be sure to use appropriate value
         * constants from {@link QuestNavCommandType}. Setting an invalid value
         * can cause {@link ProtobufQuestNavCommand#getType()} to return null
         *
         * @param value the numeric wire value to set
         * @return this
         */
        public ProtobufQuestNavCommand setTypeValue(final int value) {
            bitField0_ |= 0x00000004;
            type = value;
            return this;
        }

        /**
         * <pre>
         *
         *  The type of command being sent.
         *  
         *  This field determines which payload (if any) should be populated and
         *  how the Quest should process the command. See QuestNavCommandType
         *  enum for available command types.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.QuestNavCommandType type = 1;</code>
         * @param value the type to set
         * @return this
         */
        public ProtobufQuestNavCommand setType(final QuestNavCommandType value) {
            bitField0_ |= 0x00000004;
            type = value.getNumber();
            return this;
        }

        /**
         * <pre>
         *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         * @return whether the poseResetPayload field is set
         */
        public boolean hasPoseResetPayload() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         * @return this
         */
        public ProtobufQuestNavCommand clearPoseResetPayload() {
            bitField0_ &= ~0x00000001;
            poseResetPayload.clear();
            return this;
        }

        /**
         * <pre>
         *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutablePoseResetPayload()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public ProtobufQuestNavPoseResetPayload getPoseResetPayload() {
            return poseResetPayload;
        }

        /**
         * <pre>
         *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public ProtobufQuestNavPoseResetPayload getMutablePoseResetPayload() {
            bitField0_ |= 0x00000001;
            return poseResetPayload;
        }

        /**
         * <pre>
         *
         *  Payload for POSE_RESET commands.
         *  Set this field when type = POSE_RESET.
         * </pre>
         *
         * <code>optional .questnav.protos.commands.ProtobufQuestNavPoseResetPayload pose_reset_payload = 10;</code>
         * @param value the poseResetPayload to set
         * @return this
         */
        public ProtobufQuestNavCommand setPoseResetPayload(
                final ProtobufQuestNavPoseResetPayload value) {
            bitField0_ |= 0x00000001;
            poseResetPayload.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavCommand copyFrom(final ProtobufQuestNavCommand other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                commandId = other.commandId;
                type = other.type;
                poseResetPayload.copyFrom(other.poseResetPayload);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommand mergeFrom(final ProtobufQuestNavCommand other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasCommandId()) {
                setCommandId(other.commandId);
            }
            if (other.hasType()) {
                setTypeValue(other.type);
            }
            if (other.hasPoseResetPayload()) {
                getMutablePoseResetPayload().mergeFrom(other.poseResetPayload);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommand clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            commandId = 0;
            type = 0;
            poseResetPayload.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavCommand clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            poseResetPayload.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavCommand)) {
                return false;
            }
            ProtobufQuestNavCommand other = (ProtobufQuestNavCommand) o;
            return bitField0_ == other.bitField0_
                && (!hasCommandId() || commandId == other.commandId)
                && (!hasType() || type == other.type)
                && (!hasPoseResetPayload() || poseResetPayload.equals(other.poseResetPayload));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 16);
                output.writeUInt32NoTag(commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 8);
                output.writeEnumNoTag(type);
            }
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 82);
                output.writeMessageNoTag(poseResetPayload);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeUInt32SizeNoTag(commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeEnumSizeNoTag(type);
            }
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(poseResetPayload);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavCommand mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 16: {
                        // commandId
                        commandId = input.readUInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 8) {
                            break;
                        }
                    }
                    case 8: {
                        // type
                        final int value = input.readInt32();
                        if (QuestNavCommandType.forNumber(value) != null) {
                            type = value;
                            bitField0_ |= 0x00000004;
                        }
                        tag = input.readTag();
                        if (tag != 82) {
                            break;
                        }
                    }
                    case 82: {
                        // poseResetPayload
                        input.readMessage(poseResetPayload);
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeUInt32(FieldNames.commandId, commandId);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeEnum(FieldNames.type, type, QuestNavCommandType.converter());
            }
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeMessage(FieldNames.poseResetPayload, poseResetPayload);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavCommand mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1498725946:
                    case 784157327: {
                        if (input.isAtField(FieldNames.commandId)) {
                            if (!input.trySkipNullValue()) {
                                commandId = input.readUInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 3575610: {
                        if (input.isAtField(FieldNames.type)) {
                            if (!input.trySkipNullValue()) {
                                final QuestNavCommandType value = input.readEnum(QuestNavCommandType.converter());
                                if (value != null) {
                                    type = value.getNumber();
                                    bitField0_ |= 0x00000004;
                                } else {
                                    input.skipUnknownEnumValue();
                                }
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -305975184:
                    case -1565360272: {
                        if (input.isAtField(FieldNames.poseResetPayload)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(poseResetPayload);
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavCommand clone() {
            return new ProtobufQuestNavCommand().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavCommand parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommand(), data).checkInitialized();
        }

        public static ProtobufQuestNavCommand parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommand(), input).checkInitialized();
        }

        public static ProtobufQuestNavCommand parseFrom(final JsonSource input) throws IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommand(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavCommand messages
         */
        public static MessageFactory<ProtobufQuestNavCommand> getFactory() {
            return ProtobufQuestNavCommandFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_ProtobufQuestNavCommand_descriptor;
        }

        private enum ProtobufQuestNavCommandFactory implements MessageFactory<ProtobufQuestNavCommand> {
            INSTANCE;

            @Override
            public ProtobufQuestNavCommand create() {
                return ProtobufQuestNavCommand.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName commandId = FieldName.forField("commandId", "command_id");

            static final FieldName type = FieldName.forField("type");

            static final FieldName poseResetPayload = FieldName.forField("poseResetPayload", "pose_reset_payload");
        }
    }

    /**
     * <pre>
     *
     *  Response message sent back after processing a command.
     *  
     *  This message is sent by the Quest back to the client after processing
     *  a ProtobufQuestNavCommand. It provides status information about whether
     *  the command was executed successfully and any error details if it failed.
     *  
     *  The response is matched to the original command using the command_id field,
     *  allowing for proper asynchronous command handling even when multiple
     *  commands are in flight simultaneously.
     *  
     *  Response Timing:
     *  - Responses are sent after command processing completes
     *  - Some commands may take time to execute (e.g., pose reset with validation)
     *  - Clients should implement timeouts for command responses
     *  
     *  Note: For FRC users, the vendor dependency will handle response matching automatically.
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavCommandResponse}
     */
    public static final class ProtobufQuestNavCommandResponse extends ProtoMessage<ProtobufQuestNavCommandResponse> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         */
        private int commandId;

        /**
         * <pre>
         *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         */
        private boolean success;

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         */
        private final Utf8String errorMessage = Utf8String.newEmptyInstance();

        private ProtobufQuestNavCommandResponse() {
        }

        /**
         * <pre>
         *
         *  Response message sent back after processing a command.
         *  
         *  This message is sent by the Quest back to the client after processing
         *  a ProtobufQuestNavCommand. It provides status information about whether
         *  the command was executed successfully and any error details if it failed.
         *  
         *  The response is matched to the original command using the command_id field,
         *  allowing for proper asynchronous command handling even when multiple
         *  commands are in flight simultaneously.
         *  
         *  Response Timing:
         *  - Responses are sent after command processing completes
         *  - Some commands may take time to execute (e.g., pose reset with validation)
         *  - Clients should implement timeouts for command responses
         *  
         *  Note: For FRC users, the vendor dependency will handle response matching automatically.
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavCommandResponse}
         */
        public static ProtobufQuestNavCommandResponse newInstance() {
            return new ProtobufQuestNavCommandResponse();
        }

        /**
         * <pre>
         *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return whether the commandId field is set
         */
        public boolean hasCommandId() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return this
         */
        public ProtobufQuestNavCommandResponse clearCommandId() {
            bitField0_ &= ~0x00000001;
            commandId = 0;
            return this;
        }

        /**
         * <pre>
         *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @return the commandId
         */
        public int getCommandId() {
            return commandId;
        }

        /**
         * <pre>
         *
         *  Command ID that matches the original command.
         *  
         *  This field echoes the command_id from the original ProtobufQuestNavCommand
         *  that this response corresponds to. Clients use this to match responses
         *  with their original commands in asynchronous communication.
         * </pre>
         *
         * <code>optional uint32 command_id = 1;</code>
         * @param value the commandId to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setCommandId(final int value) {
            bitField0_ |= 0x00000001;
            commandId = value;
            return this;
        }

        /**
         * <pre>
         *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return whether the success field is set
         */
        public boolean hasSuccess() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return this
         */
        public ProtobufQuestNavCommandResponse clearSuccess() {
            bitField0_ &= ~0x00000002;
            success = false;
            return this;
        }

        /**
         * <pre>
         *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @return the success
         */
        public boolean getSuccess() {
            return success;
        }

        /**
         * <pre>
         *
         *  Indicates whether the command was executed successfully.
         *  
         *  true:  Command completed successfully
         *  false: Command failed (see error_message for details)
         *  
         *  Note: A successful response means the command was processed, but doesn't
         *  necessarily guarantee the desired outcome (e.g., pose reset might succeed
         *  but tracking could still be poor due to environmental conditions).
         * </pre>
         *
         * <code>optional bool success = 2;</code>
         * @param value the success to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setSuccess(final boolean value) {
            bitField0_ |= 0x00000002;
            success = value;
            return this;
        }

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return whether the errorMessage field is set
         */
        public boolean hasErrorMessage() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return this
         */
        public ProtobufQuestNavCommandResponse clearErrorMessage() {
            bitField0_ &= ~0x00000004;
            errorMessage.clear();
            return this;
        }

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return the errorMessage
         */
        public String getErrorMessage() {
            return errorMessage.getString();
        }

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return internal {@code Utf8String} representation of errorMessage for reading
         */
        public Utf8String getErrorMessageBytes() {
            return this.errorMessage;
        }

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @return internal {@code Utf8String} representation of errorMessage for modifications
         */
        public Utf8String getMutableErrorMessageBytes() {
            bitField0_ |= 0x00000004;
            return this.errorMessage;
        }

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @param value the errorMessage to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setErrorMessage(final CharSequence value) {
            bitField0_ |= 0x00000004;
            errorMessage.copyFrom(value);
            return this;
        }

        /**
         * <pre>
         *
         *  Human-readable error message when success = false.
         *  
         *  This field provides detailed information about why a command failed.
         *  It should be empty or ignored when success = true.
         *  
         *  Error messages are intended for debugging and logging purposes.
         *  They may include technical details about the failure cause.
         *  
         *  Examples:
         *  - "Invalid pose coordinates: x value out of field bounds"
         *  - "Tracking system not initialized"
         *  - "Unknown command type"
         * </pre>
         *
         * <code>optional string error_message = 3;</code>
         * @param value the errorMessage to set
         * @return this
         */
        public ProtobufQuestNavCommandResponse setErrorMessage(final Utf8String value) {
            bitField0_ |= 0x00000004;
            errorMessage.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse copyFrom(
                final ProtobufQuestNavCommandResponse other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                commandId = other.commandId;
                success = other.success;
                errorMessage.copyFrom(other.errorMessage);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse mergeFrom(
                final ProtobufQuestNavCommandResponse other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasCommandId()) {
                setCommandId(other.commandId);
            }
            if (other.hasSuccess()) {
                setSuccess(other.success);
            }
            if (other.hasErrorMessage()) {
                getMutableErrorMessageBytes().copyFrom(other.errorMessage);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            commandId = 0;
            success = false;
            errorMessage.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            errorMessage.clear();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavCommandResponse)) {
                return false;
            }
            ProtobufQuestNavCommandResponse other = (ProtobufQuestNavCommandResponse) o;
            return bitField0_ == other.bitField0_
                && (!hasCommandId() || commandId == other.commandId)
                && (!hasSuccess() || success == other.success)
                && (!hasErrorMessage() || errorMessage.equals(other.errorMessage));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 8);
                output.writeUInt32NoTag(commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 16);
                output.writeBoolNoTag(success);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 26);
                output.writeStringNoTag(errorMessage);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeUInt32SizeNoTag(commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 2;
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeStringSizeNoTag(errorMessage);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavCommandResponse mergeFrom(final ProtoSource input) throws
                IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 8: {
                        // commandId
                        commandId = input.readUInt32();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // success
                        success = input.readBool();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 26) {
                            break;
                        }
                    }
                    case 26: {
                        // errorMessage
                        input.readString(errorMessage);
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeUInt32(FieldNames.commandId, commandId);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeBool(FieldNames.success, success);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeString(FieldNames.errorMessage, errorMessage);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavCommandResponse mergeFrom(final JsonSource input) throws
                IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1498725946:
                    case 784157327: {
                        if (input.isAtField(FieldNames.commandId)) {
                            if (!input.trySkipNullValue()) {
                                commandId = input.readUInt32();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -1867169789: {
                        if (input.isAtField(FieldNames.success)) {
                            if (!input.trySkipNullValue()) {
                                success = input.readBool();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 1203236063:
                    case -1938755376: {
                        if (input.isAtField(FieldNames.errorMessage)) {
                            if (!input.trySkipNullValue()) {
                                input.readString(errorMessage);
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavCommandResponse clone() {
            return new ProtobufQuestNavCommandResponse().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavCommandResponse parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommandResponse(), data).checkInitialized();
        }

        public static ProtobufQuestNavCommandResponse parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommandResponse(), input).checkInitialized();
        }

        public static ProtobufQuestNavCommandResponse parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavCommandResponse(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavCommandResponse messages
         */
        public static MessageFactory<ProtobufQuestNavCommandResponse> getFactory() {
            return ProtobufQuestNavCommandResponseFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Commands.questnav_protos_commands_ProtobufQuestNavCommandResponse_descriptor;
        }

        private enum ProtobufQuestNavCommandResponseFactory implements MessageFactory<ProtobufQuestNavCommandResponse> {
            INSTANCE;

            @Override
            public ProtobufQuestNavCommandResponse create() {
                return ProtobufQuestNavCommandResponse.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName commandId = FieldName.forField("commandId", "command_id");

            static final FieldName success = FieldName.forField("success");

            static final FieldName errorMessage = FieldName.forField("errorMessage", "error_message");
        }
    }
}