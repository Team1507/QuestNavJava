// Code generated by protocol buffer compiler. Do not edit!
package frc.robot.generated;

import edu.wpi.first.math.proto.Geometry3D;
import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedByte;

public final class Data {
    private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(7014,
        "CgpkYXRhLnByb3RvEhRxdWVzdG5hdi5wcm90b3MuZGF0YRoQZ2VvbWV0cnkzZC5wcm90byKNAQoZUHJv" + 
        "dG9idWZRdWVzdE5hdkZyYW1lRGF0YRIfCgtmcmFtZV9jb3VudBgBIAEoBVIKZnJhbWVDb3VudBIcCgl0" + 
        "aW1lc3RhbXAYAiABKAFSCXRpbWVzdGFtcBIxCgZwb3NlM2QYAyABKAsyGS53cGkucHJvdG8uUHJvdG9i" + 
        "dWZQb3NlM2RSBnBvc2UzZCKoAQoaUHJvdG9idWZRdWVzdE5hdkRldmljZURhdGESMgoVdHJhY2tpbmdf" + 
        "bG9zdF9jb3VudGVyGAEgASgFUhN0cmFja2luZ0xvc3RDb3VudGVyEi0KEmN1cnJlbnRseV90cmFja2lu" + 
        "ZxgCIAEoCFIRY3VycmVudGx5VHJhY2tpbmcSJwoPYmF0dGVyeV9wZXJjZW50GAMgASgFUg5iYXR0ZXJ5" + 
        "UGVyY2VudEJDCiVnZy5xdWVzdG5hdi5xdWVzdG5hdi5wcm90b3MuZ2VuZXJhdGVkqgIZUXVlc3ROYXYu" + 
        "UHJvdG9zLkdlbmVyYXRlZEqnMwoHEgUAA8ABAQoICgEMEgMAAxUK4wYKAQISAxYAHTLYBgogUXVlc3RO" + 
        "YXYgRGF0YSBQcm90b2NvbCBCdWZmZXIgRGVmaW5pdGlvbnMKIAogVGhpcyBmaWxlIGRlZmluZXMgdGhl" + 
        "IGRhdGEgc3RydWN0dXJlcyB1c2VkIGZvciB0cmFuc21pdHRpbmcgdHJhY2tpbmcgYW5kIGRldmljZQog" + 
        "aW5mb3JtYXRpb24gZnJvbSB0aGUgUXVlc3QgaGVhZHNldCB0byBleHRlcm5hbCBzeXN0ZW1zIChzdWNo" + 
        "IGFzIHJvYm90IGNvZGUpLgogVGhlIGRhdGEgaXMgb3JnYW5pemVkIGludG8gdHdvIG1haW4gY2F0ZWdv" + 
        "cmllcyB3aXRoIGRpZmZlcmVudCB1cGRhdGUgZnJlcXVlbmNpZXM6CiAKIDEuIEZyYW1lIERhdGE6IEhp" + 
        "Z2gtZnJlcXVlbmN5IHRyYWNraW5nIGluZm9ybWF0aW9uIChwb3NlLCB0aW1lc3RhbXBzKQogMi4gRGV2" + 
        "aWNlIERhdGE6IExvd2VyLWZyZXF1ZW5jeSBkZXZpY2Ugc3RhdHVzIGluZm9ybWF0aW9uIChiYXR0ZXJ5" + 
        "LCB0cmFja2luZyBzdGF0ZSkKIAogVGhpcyBzZXBhcmF0aW9uIGFsbG93cyBmb3IgZWZmaWNpZW50IGJh" + 
        "bmR3aWR0aCB1c2FnZSBieSBzZW5kaW5nIGNyaXRpY2FsIHRyYWNraW5nCiBkYXRhIGZyZXF1ZW50bHkg" + 
        "d2hpbGUgc2VuZGluZyBsZXNzIGNyaXRpY2FsIGRldmljZSBzdGF0dXMgZGF0YSBhdCBhIGxvd2VyIHJh" + 
        "dGUuCiAKIERhdGEgRmxvdzoKIC0gUXVlc3QgY29udGludW91c2x5IHByb2Nlc3NlcyBjYW1lcmEvc2Vu" + 
        "c29yIGRhdGEKIC0gRnJhbWUgZGF0YSBpcyBzZW50IGV2ZXJ5IDEwIG1pbGxpc2Vjb25kcyAoMTAwIEh6",
        "KQogLSBEZXZpY2UgZGF0YSBpcyBzZW50IGV2ZXJ5IDMzMyBtaWxsaXNlY29uZHMgKDMgSHopCiAtIEV4" + 
        "dGVybmFsIHN5c3RlbXMgcmVjZWl2ZSBhbmQgcHJvY2VzcyB0aGlzIGRhdGEgZm9yIHJvYm90IGxvY2Fs" + 
        "aXphdGlvbgoKCAoBCBIDFwA2CgkKAgglEgMXADYKCAoBCBIDGAA+CgkKAggBEgMYAD4KPQoCAwASAxsA" + 
        "GhoyIEltcG9ydCBnZW9tZXRyeSBtZXNzYWdlcyBmb3IgcG9zZSByZXByZXNlbnRhdGlvbgoKvwUKAgQA" + 
        "EgQtAGkBGrIFCiBIaWdoLWZyZXF1ZW5jeSB0cmFja2luZyBkYXRhIHNlbnQgZnJvbSBRdWVzdCB0byBl" + 
        "eHRlcm5hbCBzeXN0ZW1zLgogCiBUaGlzIG1lc3NhZ2UgY29udGFpbnMgdGhlIGNvcmUgdHJhY2tpbmcg" + 
        "aW5mb3JtYXRpb24gdGhhdCBleHRlcm5hbCBzeXN0ZW1zCiAobGlrZSByb2JvdCBjb2RlKSBuZWVkIGZv" + 
        "ciByZWFsLXRpbWUgbG9jYWxpemF0aW9uIGFuZCBuYXZpZ2F0aW9uLiBJdCdzIHNlbnQKIGF0IDEwMCBI" + 
        "eiAoZXZlcnkgMTAgbWlsbGlzZWNvbmRzKSB0byBwcm92aWRlIHNtb290aCwgcmVzcG9uc2l2ZSB0cmFj" + 
        "a2luZy4KIAogVGhlIGRhdGEgcmVwcmVzZW50cyB0aGUgUXVlc3QncyBwb3NpdGlvbiBhbmQgb3JpZW50" + 
        "YXRpb24gb24gdGhlIGZpZWxkLAogZGVyaXZlZCBmcm9tIHZpc3VhbC1pbmVydGlhbCBvZG9tZXRyeSB1" + 
        "c2luZyB0aGUgUXVlc3QncyBjYW1lcmFzIGFuZCBJTVUgc2Vuc29ycy4KIAogQ29vcmRpbmF0ZSBTeXN0" + 
        "ZW06CiAtIFVzZXMgV1BJTGliIGZpZWxkLXJlbGF0aXZlIGNvb3JkaW5hdGUgc3lzdGVtCiAtIE9yaWdp" + 
        "biBhbmQgYXhlcyBkZXBlbmQgb24gZmllbGQgc2V0dXAgYW5kIGNhbGlicmF0aW9uCiAtIFBvc2UgcmVw" + 
        "cmVzZW50cyB0aGUgUXVlc3QncyBwb3NpdGlvbjsgbW91bnRpbmcgb2Zmc2V0IHRvIGdldCByb2JvdCBw" + 
        "b3NpdGlvbgogICBpcyBhcHBsaWVkIGluIGVuZCB1c2VyIGNvZGUKCgoKAwQAARIDLQghCrcDCgQEAAIA" + 
        "EgM7AhgaqQMKIFNlcXVlbnRpYWwgZnJhbWUgY291bnRlciBmb3IgdGhpcyB0cmFja2luZyBzZXNzaW9u" + 
        "LgogCiBUaGlzIGNvdW50ZXIgaW5jcmVtZW50cyB3aXRoIGVhY2ggZnJhbWUgcHJvY2Vzc2VkIGJ5IHRo" + 
        "ZSBRdWVzdCdzIHRyYWNraW5nCiBzeXN0ZW0uIEl0IGNhbiBiZSB1c2VkIHRvOgogLSBEZXRlY3QgZHJv" + 
        "cHBlZCBtZXNzYWdlcwogLSBDYWxjdWxhdGUgZWZmZWN0aXZlIGZyYW1lIHJhdGUKIC0gU3luY2hyb25p",
        "emUgd2l0aCBvdGhlciBkYXRhIHN0cmVhbXMKIAogVGhlIGNvdW50ZXIgcmVzZXRzIHRvIDAgd2hlbiB0" + 
        "aGUgUXVlc3ROYXYgYXBwIHN0YXJ0cyBhbmQgaW5jcmVtZW50cwogY29udGludW91c2x5IGR1cmluZyBv" + 
        "cGVyYXRpb24uIEZyYW1lIGRyb3BzIGluIHRyYW5zbWlzc2lvbiB3aWxsIGNyZWF0ZQogZ2FwcyBpbiB0" + 
        "aGUgc2VxdWVuY2UuCgoMCgUEAAIABRIDOwIHCgwKBQQAAgABEgM7CBMKDAoFBAACAAMSAzsWFwreAwoE" + 
        "BAACARIDTAIXGtADCiBUaW1lc3RhbXAgaW4gc2Vjb25kcyBzaW5jZSBRdWVzdE5hdiBhcHAgc3RhcnR1" + 
        "cC4KIAogVGhpcyBwcm92aWRlcyB0aW1pbmcgaW5mb3JtYXRpb24gZm9yIHRoZSB0cmFja2luZyBkYXRh" + 
        "LCBhbGxvd2luZyBleHRlcm5hbAogc3lzdGVtcyB0bzoKIC0gQ2FsY3VsYXRlIGRhdGEgYWdlIGFuZCBs" + 
        "YXRlbmN5CiAtIEludGVycG9sYXRlIG9yIGV4dHJhcG9sYXRlIHBvc2VzIGZvciBwcmVkaWN0aW9uCiAt" + 
        "IFN5bmNocm9uaXplIHdpdGggb3RoZXIgc2Vuc29yIGRhdGEKIC0gSW1wbGVtZW50IHRpbWVvdXQgZGV0" + 
        "ZWN0aW9uCiAKIFRoZSB0aW1lc3RhbXAgaXMgcmVsYXRpdmUgdG8gYXBwIHN0YXJ0dXAsIG5vdCBzeXN0" + 
        "ZW0gdGltZSwgdG8gYXZvaWQKIGNsb2NrIHN5bmNocm9uaXphdGlvbiBpc3N1ZXMgYmV0d2VlbiBkZXZp" + 
        "Y2VzLgogCiBSZXNvbHV0aW9uOiBUeXBpY2FsbHkgc3ViLW1pbGxpc2Vjb25kIHByZWNpc2lvbgoKDAoF" + 
        "BAACAQUSA0wCCAoMCgUEAAIBARIDTAkSCgwKBQQAAgEDEgNMFRYKtAcKBAQAAgISA2gCJhqmBwogUXVl" + 
        "c3QncyAzRCBwb3NlIG9uIHRoZSBmaWVsZCBpbiBXUElMaWIgY29vcmRpbmF0ZXMuCiAKIFRoaXMgcmVw" + 
        "cmVzZW50cyB0aGUgUXVlc3QncyBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gYXMgZGV0ZXJtaW5lZCBi" + 
        "eQogdGhlIFF1ZXN0J3MgdHJhY2tpbmcgc3lzdGVtLiBUaGUgcG9zZSBhY2NvdW50cyBmb3I6CiAtIENv" + 
        "b3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9uIHRvIFdQSUxpYiBzdGFuZGFyZAogLSBBbnkgY2Fs" + 
        "aWJyYXRpb24gb2Zmc2V0cyBhcHBsaWVkCiAKIE5vdGU6IFRoaXMgaXMgdGhlIFF1ZXN0J3MgcG9zaXRp" + 
        "b247IGVuZCB1c2VyIGNvZGUgYXBwbGllcyBtb3VudGluZyBvZmZzZXQKIHRvIGdldCB0aGUgcm9ib3Qn" + 
        "cyBwb3NpdGlvbi4KIAogQ29vcmRpbmF0ZSBTeXN0ZW0gRGV0YWlsczoKIC0gWDogRm9yd2FyZCBkaXJl",
        "Y3Rpb24gKHRvd2FyZHMgb3Bwb3NpbmcgYWxsaWFuY2UpCiAtIFk6IExlZnQgZGlyZWN0aW9uICh3aGVu" + 
        "IGZhY2luZyBmb3J3YXJkKQogLSBaOiBVcCBkaXJlY3Rpb24KIC0gWWF3IChaKTogQ291bnRlci1jbG9j" + 
        "a3dpc2UgKHJpZ2h0LWhhbmRlZCkgcm90YXRpb24gYXJvdW5kIHRoZSBaIGF4aXMKIC0gUGl0Y2ggKFkp" + 
        "OiBDb3VudGVyLWNsb2Nrd2lzZSAocmlnaHQtaGFuZGVkKSByb3RhdGlvbiBhcm91bmQgWSBheGlzCiAt" + 
        "IFJvbGwgKFgpOiBDb3VudGVyLWNsb2Nrd2lzZSAocmlnaHQtaGFuZGVkKSByb3RhdGlvbiBhcm91bmQg" + 
        "dGhlIFggYXhpcwogLSBVbml0czogbWV0ZXJzIGZvciB0cmFuc2xhdGlvbiwgcmFkaWFucyBmb3Igcm90" + 
        "YXRpb24KIAogQWNjdXJhY3kgZGVwZW5kcyBvbjoKIC0gRW52aXJvbm1lbnRhbCBsaWdodGluZyBhbmQg" + 
        "ZmVhdHVyZXMKIC0gUXVlc3QgdHJhY2tpbmcgcXVhbGl0eQogLSBDYWxpYnJhdGlvbiBhY2N1cmFjeQog" + 
        "LSBUaW1lIHNpbmNlIGxhc3QgcG9zZSByZXNldAoKDAoFBAACAgYSA2gCGgoMCgUEAAICARIDaBshCgwK" + 
        "BQQAAgIDEgNoJCUK8QQKAgQBEgV8AMABARrjBAogTG93ZXItZnJlcXVlbmN5IGRldmljZSBzdGF0dXMg" + 
        "ZGF0YSBzZW50IGZyb20gUXVlc3QgdG8gZXh0ZXJuYWwgc3lzdGVtcy4KIAogVGhpcyBtZXNzYWdlIGNv" + 
        "bnRhaW5zIGRldmljZSBoZWFsdGggYW5kIHN0YXR1cyBpbmZvcm1hdGlvbiB0aGF0IGRvZXNuJ3QgbmVl" + 
        "ZAogdG8gYmUgc2VudCBhcyBmcmVxdWVudGx5IGFzIHRyYWNraW5nIGRhdGEuIEl0J3Mgc2VudCBhdCAz" + 
        "IEh6IChldmVyeSAzMzMgbWlsbGlzZWNvbmRzKQogdG8gcHJvdmlkZSBtb25pdG9yaW5nIGFuZCBkaWFn" + 
        "bm9zdGljIGluZm9ybWF0aW9uIHdpdGhvdXQgY29uc3VtaW5nIGV4Y2Vzc2l2ZQogYmFuZHdpZHRoLgog" + 
        "CiBUaGlzIGRhdGEgaGVscHMgZXh0ZXJuYWwgc3lzdGVtczoKIC0gTW9uaXRvciBRdWVzdCBkZXZpY2Ug" + 
        "aGVhbHRoCiAtIERldGVjdCB0cmFja2luZyBzeXN0ZW0gaXNzdWVzCiAtIEltcGxlbWVudCBmYWlsc2Fm" + 
        "ZSBiZWhhdmlvcnMKIC0gUHJvdmlkZSB1c2VyIGZlZWRiYWNrIGFib3V0IHN5c3RlbSBzdGF0dXMKIAog" + 
        "VGhlIGluZm9ybWF0aW9uIGlzIHVzZWZ1bCBmb3IgYm90aCBhdXRvbm9tb3VzIG9wZXJhdGlvbiBhbmQg" + 
        "ZGVidWdnaW5nLwogdHJvdWJsZXNob290aW5nIHNjZW5hcmlvcy4KCgoKAwQBARIDfAgiCoUFCgQEAQIA",
        "EgSQAQIiGvYECiBDb3VudCBvZiB0cmFja2luZyBsb3NzIGV2ZW50cyBzaW5jZSBhcHAgc3RhcnR1cC4K" + 
        "IAogVGhpcyBjb3VudGVyIGluY3JlbWVudHMgZWFjaCB0aW1lIHRoZSBRdWVzdCdzIHRyYWNraW5nIHN5" + 
        "c3RlbSBsb3NlcwogdHJhY2tpbmcgYWZ0ZXIgaGF2aW5nIGVzdGFibGlzaGVkIGl0LiBUcmFja2luZyBs" + 
        "b3NzIGNhbiBvY2N1ciBkdWUgdG86CiAtIFBvb3IgbGlnaHRpbmcgY29uZGl0aW9ucwogLSBMYWNrIG9m" + 
        "IHZpc3VhbCBmZWF0dXJlcyBpbiBlbnZpcm9ubWVudAogLSBSYXBpZCBtb3Rpb24gb3IgYWNjZWxlcmF0" + 
        "aW9uCiAtIE9jY2x1c2lvbiBvZiBjYW1lcmFzCiAtIEhhcmR3YXJlIGlzc3VlcwogCiBBIGhpZ2ggb3Ig" + 
        "cmFwaWRseSBpbmNyZWFzaW5nIGNvdW50ZXIgbWF5IGluZGljYXRlOgogLSBFbnZpcm9ubWVudGFsIGlz" + 
        "c3VlcyAobGlnaHRpbmcsIGZlYXR1cmVzKQogLSBRdWVzdCBtb3VudGluZyBwcm9ibGVtcyAodmlicmF0" + 
        "aW9uLCBvYnN0cnVjdGlvbikKIC0gSGFyZHdhcmUgZGVncmFkYXRpb24KIAogVGhpcyBtZXRyaWMgaGVs" + 
        "cHMgYXNzZXNzIHRyYWNraW5nIHN5c3RlbSByZWxpYWJpbGl0eSBhbmQgY2FuIHRyaWdnZXIKIGFsZXJ0" + 
        "cyBvciBmYWxsYmFjayBiZWhhdmlvcnMgaW4gcm9ib3QgY29kZS4KCg0KBQQBAgAFEgSQAQIHCg0KBQQB" + 
        "AgABEgSQAQgdCg0KBQQBAgADEgSQASAhCrkFCgQEAQIBEgSmAQIeGqoFCiBDdXJyZW50IHRyYWNraW5n" + 
        "IHN0YXR1cyBvZiB0aGUgUXVlc3QgZGV2aWNlLgogCiB0cnVlOiAgUXVlc3QgaXMgYWN0aXZlbHkgdHJh" + 
        "Y2tpbmcgYW5kIHBvc2UgZGF0YSBpcyByZWxpYWJsZQogZmFsc2U6IFF1ZXN0IGhhcyBsb3N0IHRyYWNr" + 
        "aW5nIGFuZCBwb3NlIGRhdGEgc2hvdWxkIG5vdCBiZSB0cnVzdGVkCiAKIFdoZW4gdHJhY2tpbmcgaXMg" + 
        "bG9zdDoKIC0gUG9zZSBkYXRhIGJlY29tZXMgc3RhbGUgYW5kIHVucmVsaWFibGUKIC0gUm9ib3Qgc2hv" + 
        "dWxkIHN3aXRjaCB0byBhbHRlcm5hdGl2ZSBsb2NhbGl6YXRpb24gbWV0aG9kcwogLSBNb3ZlbWVudCBz" + 
        "aG91bGQgYmUgbGltaXRlZCBvciBzdG9wcGVkIGZvciBzYWZldHkKIAogVHJhY2tpbmcgY2FuIGJlIHJl" + 
        "Y292ZXJlZCBieToKIC0gSW1wcm92aW5nIGxpZ2h0aW5nIGNvbmRpdGlvbnMKIC0gTW92aW5nIHRvIGFy" + 
        "ZWEgd2l0aCBtb3JlIHZpc3VhbCBmZWF0dXJlcwogLSBSZWR1Y2luZyBtb3Rpb24gdG8gYWxsb3cgc3lz",
        "dGVtIHRvIHJlLWluaXRpYWxpemUKIC0gUGVyZm9ybWluZyBwb3NlIHJlc2V0IHdoZW4gdHJhY2tpbmcg" + 
        "cmVjb3ZlcnMKIAogRXh0ZXJuYWwgc3lzdGVtcyBzaG91bGQgbW9uaXRvciB0aGlzIGZpZWxkIGFuZCBp" + 
        "bXBsZW1lbnQgYXBwcm9wcmlhdGUKIGZhbGxiYWNrIGJlaGF2aW9ycyB3aGVuIHRyYWNraW5nIGlzIGxv" + 
        "c3QuCgoNCgUEAQIBBRIEpgECBgoNCgUEAQIBARIEpgEHGQoNCgUEAQIBAxIEpgEcHQrZBQoEBAECAhIE" + 
        "vwECHBrKBQogUXVlc3QgZGV2aWNlIGJhdHRlcnkgbGV2ZWwgYXMgYSBwZXJjZW50YWdlICgwLTEwMCku" + 
        "CiAKIFRoaXMgcHJvdmlkZXMgdGhlIGN1cnJlbnQgYmF0dGVyeSBjaGFyZ2UgbGV2ZWwgb2YgdGhlIFF1" + 
        "ZXN0IGhlYWRzZXQsCiBhbGxvd2luZyBleHRlcm5hbCBzeXN0ZW1zIHRvOgogLSBNb25pdG9yIHBvd2Vy" + 
        "IHN0YXR1cyBkdXJpbmcgb3BlcmF0aW9uCiAtIEltcGxlbWVudCBsb3ctYmF0dGVyeSB3YXJuaW5ncyBv" + 
        "ciBiZWhhdmlvcnMKIC0gUGxhbiBvcGVyYXRpb24gZHVyYXRpb24gYW5kIGNoYXJnaW5nIG5lZWRzCiAt" + 
        "IFRyaWdnZXIgZ3JhY2VmdWwgc2h1dGRvd24gcHJvY2VkdXJlcwogCiBCYXR0ZXJ5IExldmVsIEd1aWRl" + 
        "bGluZXM6CiAtIDEwMCU6IEZ1bGx5IGNoYXJnZWQKIC0gNTAtMTAwJTogTm9ybWFsIG9wZXJhdGlvbgog" + 
        "LSAyMC01MCU6IENvbnNpZGVyIGNoYXJnaW5nIHNvb24KIC0gMTAtMjAlOiBMb3cgYmF0dGVyeSB3YXJu" + 
        "aW5nIHJlY29tbWVuZGVkCiAtIDAtMTAlOiBDcml0aWNhbCAtIHBsYW4gaW1tZWRpYXRlIHNodXRkb3du" + 
        "L2NoYXJnaW5nCiAKIE5vdGU6IEJhdHRlcnkgZHJhaW4gcmF0ZSBkZXBlbmRzIG9uOgogLSBQcm9jZXNz" + 
        "aW5nIGxvYWQgKHRyYWNraW5nIGNvbXBsZXhpdHkpCiAtIERpc3BsYXkgdXNhZ2UgKGlmIGFueSkKIC0g" + 
        "V2lyZWxlc3MgY29tbXVuaWNhdGlvbiBhY3Rpdml0eQogLSBFbnZpcm9ubWVudGFsIHRlbXBlcmF0dXJl" + 
        "CgoNCgUEAQICBRIEvwECBwoNCgUEAQICARIEvwEIFwoNCgUEAQICAxIEvwEaG2IGcHJvdG8z");

    static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("data.proto", "questnav.protos.data", descriptorData, Geometry3D.getDescriptor());

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavFrameData_descriptor = descriptor.internalContainedType(55, 141, "ProtobufQuestNavFrameData", "questnav.protos.data.ProtobufQuestNavFrameData");

    static final Descriptors.Descriptor questnav_protos_data_ProtobufQuestNavDeviceData_descriptor = descriptor.internalContainedType(199, 168, "ProtobufQuestNavDeviceData", "questnav.protos.data.ProtobufQuestNavDeviceData");

    /**
     * @return this proto file's descriptor.
     */
    public static Descriptors.FileDescriptor getDescriptor() {
        return descriptor;
    }

    /**
     * <pre>
     *
     *  High-frequency tracking data sent from Quest to external systems.
     *  
     *  This message contains the core tracking information that external systems
     *  (like robot code) need for real-time localization and navigation. It's sent
     *  at 100 Hz (every 10 milliseconds) to provide smooth, responsive tracking.
     *  
     *  The data represents the Quest's position and orientation on the field,
     *  derived from visual-inertial odometry using the Quest's cameras and IMU sensors.
     *  
     *  Coordinate System:
     *  - Uses WPILib field-relative coordinate system
     *  - Origin and axes depend on field setup and calibration
     *  - Pose represents the Quest's position; mounting offset to get robot position
     *    is applied in end user code
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavFrameData}
     */
    public static final class ProtobufQuestNavFrameData extends ProtoMessage<ProtobufQuestNavFrameData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         */
        private double timestamp;

        /**
         * <pre>
         *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         */
        private int frameCount;

        /**
         * <pre>
         *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         */
        private final Geometry3D.ProtobufPose3d pose3D = Geometry3D.ProtobufPose3d.newInstance();

        private ProtobufQuestNavFrameData() {
        }

        /**
         * <pre>
         *
         *  High-frequency tracking data sent from Quest to external systems.
         *  
         *  This message contains the core tracking information that external systems
         *  (like robot code) need for real-time localization and navigation. It's sent
         *  at 100 Hz (every 10 milliseconds) to provide smooth, responsive tracking.
         *  
         *  The data represents the Quest's position and orientation on the field,
         *  derived from visual-inertial odometry using the Quest's cameras and IMU sensors.
         *  
         *  Coordinate System:
         *  - Uses WPILib field-relative coordinate system
         *  - Origin and axes depend on field setup and calibration
         *  - Pose represents the Quest's position; mounting offset to get robot position
         *    is applied in end user code
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavFrameData}
         */
        public static ProtobufQuestNavFrameData newInstance() {
            return new ProtobufQuestNavFrameData();
        }

        /**
         * <pre>
         *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return whether the timestamp field is set
         */
        public boolean hasTimestamp() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearTimestamp() {
            bitField0_ &= ~0x00000001;
            timestamp = 0D;
            return this;
        }

        /**
         * <pre>
         *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @return the timestamp
         */
        public double getTimestamp() {
            return timestamp;
        }

        /**
         * <pre>
         *
         *  Timestamp in seconds since QuestNav app startup.
         *  
         *  This provides timing information for the tracking data, allowing external
         *  systems to:
         *  - Calculate data age and latency
         *  - Interpolate or extrapolate poses for prediction
         *  - Synchronize with other sensor data
         *  - Implement timeout detection
         *  
         *  The timestamp is relative to app startup, not system time, to avoid
         *  clock synchronization issues between devices.
         *  
         *  Resolution: Typically sub-millisecond precision
         * </pre>
         *
         * <code>optional double timestamp = 2;</code>
         * @param value the timestamp to set
         * @return this
         */
        public ProtobufQuestNavFrameData setTimestamp(final double value) {
            bitField0_ |= 0x00000001;
            timestamp = value;
            return this;
        }

        /**
         * <pre>
         *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return whether the frameCount field is set
         */
        public boolean hasFrameCount() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearFrameCount() {
            bitField0_ &= ~0x00000002;
            frameCount = 0;
            return this;
        }

        /**
         * <pre>
         *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @return the frameCount
         */
        public int getFrameCount() {
            return frameCount;
        }

        /**
         * <pre>
         *
         *  Sequential frame counter for this tracking session.
         *  
         *  This counter increments with each frame processed by the Quest's tracking
         *  system. It can be used to:
         *  - Detect dropped messages
         *  - Calculate effective frame rate
         *  - Synchronize with other data streams
         *  
         *  The counter resets to 0 when the QuestNav app starts and increments
         *  continuously during operation. Frame drops in transmission will create
         *  gaps in the sequence.
         * </pre>
         *
         * <code>optional int32 frame_count = 1;</code>
         * @param value the frameCount to set
         * @return this
         */
        public ProtobufQuestNavFrameData setFrameCount(final int value) {
            bitField0_ |= 0x00000002;
            frameCount = value;
            return this;
        }

        /**
         * <pre>
         *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         * @return whether the pose3D field is set
         */
        public boolean hasPose3D() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         * @return this
         */
        public ProtobufQuestNavFrameData clearPose3D() {
            bitField0_ &= ~0x00000004;
            pose3D.clear();
            return this;
        }

        /**
         * <pre>
         *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         *
         * This method returns the internal storage object without modifying any has state.
         * The returned object should not be modified and be treated as read-only.
         *
         * Use {@link #getMutablePose3D()} if you want to modify it.
         *
         * @return internal storage object for reading
         */
        public Geometry3D.ProtobufPose3d getPose3D() {
            return pose3D;
        }

        /**
         * <pre>
         *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         *
         * This method returns the internal storage object and sets the corresponding
         * has state. The returned object will become part of this message and its
         * contents may be modified as long as the has state is not cleared.
         *
         * @return internal storage object for modifications
         */
        public Geometry3D.ProtobufPose3d getMutablePose3D() {
            bitField0_ |= 0x00000004;
            return pose3D;
        }

        /**
         * <pre>
         *
         *  Quest's 3D pose on the field in WPILib coordinates.
         *  
         *  This represents the Quest's position and orientation as determined by
         *  the Quest's tracking system. The pose accounts for:
         *  - Coordinate system transformation to WPILib standard
         *  - Any calibration offsets applied
         *  
         *  Note: This is the Quest's position; end user code applies mounting offset
         *  to get the robot's position.
         *  
         *  Coordinate System Details:
         *  - X: Forward direction (towards opposing alliance)
         *  - Y: Left direction (when facing forward)
         *  - Z: Up direction
         *  - Yaw (Z): Counter-clockwise (right-handed) rotation around the Z axis
         *  - Pitch (Y): Counter-clockwise (right-handed) rotation around Y axis
         *  - Roll (X): Counter-clockwise (right-handed) rotation around the X axis
         *  - Units: meters for translation, radians for rotation
         *  
         *  Accuracy depends on:
         *  - Environmental lighting and features
         *  - Quest tracking quality
         *  - Calibration accuracy
         *  - Time since last pose reset
         * </pre>
         *
         * <code>optional .wpi.proto.ProtobufPose3d pose3d = 3;</code>
         * @param value the pose3D to set
         * @return this
         */
        public ProtobufQuestNavFrameData setPose3D(final Geometry3D.ProtobufPose3d value) {
            bitField0_ |= 0x00000004;
            pose3D.copyFrom(value);
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData copyFrom(final ProtobufQuestNavFrameData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                timestamp = other.timestamp;
                frameCount = other.frameCount;
                pose3D.copyFrom(other.pose3D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final ProtobufQuestNavFrameData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTimestamp()) {
                setTimestamp(other.timestamp);
            }
            if (other.hasFrameCount()) {
                setFrameCount(other.frameCount);
            }
            if (other.hasPose3D()) {
                getMutablePose3D().mergeFrom(other.pose3D);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            timestamp = 0D;
            frameCount = 0;
            pose3D.clear();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            pose3D.clearQuick();
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavFrameData)) {
                return false;
            }
            ProtobufQuestNavFrameData other = (ProtobufQuestNavFrameData) o;
            return bitField0_ == other.bitField0_
                && (!hasTimestamp() || ProtoUtil.isEqual(timestamp, other.timestamp))
                && (!hasFrameCount() || frameCount == other.frameCount)
                && (!hasPose3D() || pose3D.equals(other.pose3D));
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 17);
                output.writeDoubleNoTag(timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 26);
                output.writeMessageNoTag(pose3D);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 9;
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 1 + ProtoSink.computeMessageSizeNoTag(pose3D);
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavFrameData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 17: {
                        // timestamp
                        timestamp = input.readDouble();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 8) {
                            break;
                        }
                    }
                    case 8: {
                        // frameCount
                        frameCount = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 26) {
                            break;
                        }
                    }
                    case 26: {
                        // pose3D
                        input.readMessage(pose3D);
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeDouble(FieldNames.timestamp, timestamp);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.frameCount, frameCount);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeMessage(FieldNames.pose3D, pose3D);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavFrameData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case 55126294: {
                        if (input.isAtField(FieldNames.timestamp)) {
                            if (!input.trySkipNullValue()) {
                                timestamp = input.readDouble();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -296512606:
                    case 188405693: {
                        if (input.isAtField(FieldNames.frameCount)) {
                            if (!input.trySkipNullValue()) {
                                frameCount = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -982466846: {
                        if (input.isAtField(FieldNames.pose3D)) {
                            if (!input.trySkipNullValue()) {
                                input.readMessage(pose3D);
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavFrameData clone() {
            return new ProtobufQuestNavFrameData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavFrameData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), data).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        public static ProtobufQuestNavFrameData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavFrameData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavFrameData messages
         */
        public static MessageFactory<ProtobufQuestNavFrameData> getFactory() {
            return ProtobufQuestNavFrameDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavFrameData_descriptor;
        }

        private enum ProtobufQuestNavFrameDataFactory implements MessageFactory<ProtobufQuestNavFrameData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavFrameData create() {
                return ProtobufQuestNavFrameData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName timestamp = FieldName.forField("timestamp");

            static final FieldName frameCount = FieldName.forField("frameCount", "frame_count");

            static final FieldName pose3D = FieldName.forField("pose3d");
        }
    }

    /**
     * <pre>
     *
     *  Lower-frequency device status data sent from Quest to external systems.
     *  
     *  This message contains device health and status information that doesn't need
     *  to be sent as frequently as tracking data. It's sent at 3 Hz (every 333 milliseconds)
     *  to provide monitoring and diagnostic information without consuming excessive
     *  bandwidth.
     *  
     *  This data helps external systems:
     *  - Monitor Quest device health
     *  - Detect tracking system issues
     *  - Implement failsafe behaviors
     *  - Provide user feedback about system status
     *  
     *  The information is useful for both autonomous operation and debugging/
     *  troubleshooting scenarios.
     * </pre>
     *
     * Protobuf type {@code ProtobufQuestNavDeviceData}
     */
    public static final class ProtobufQuestNavDeviceData extends ProtoMessage<ProtobufQuestNavDeviceData> implements Cloneable {
        private static final long serialVersionUID = 0L;

        /**
         * <pre>
         *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         */
        private int trackingLostCounter;

        /**
         * <pre>
         *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         */
        private int batteryPercent;

        /**
         * <pre>
         *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         */
        private boolean currentlyTracking;

        private ProtobufQuestNavDeviceData() {
        }

        /**
         * <pre>
         *
         *  Lower-frequency device status data sent from Quest to external systems.
         *  
         *  This message contains device health and status information that doesn't need
         *  to be sent as frequently as tracking data. It's sent at 3 Hz (every 333 milliseconds)
         *  to provide monitoring and diagnostic information without consuming excessive
         *  bandwidth.
         *  
         *  This data helps external systems:
         *  - Monitor Quest device health
         *  - Detect tracking system issues
         *  - Implement failsafe behaviors
         *  - Provide user feedback about system status
         *  
         *  The information is useful for both autonomous operation and debugging/
         *  troubleshooting scenarios.
         * </pre>
         *
         * @return a new empty instance of {@code ProtobufQuestNavDeviceData}
         */
        public static ProtobufQuestNavDeviceData newInstance() {
            return new ProtobufQuestNavDeviceData();
        }

        /**
         * <pre>
         *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return whether the trackingLostCounter field is set
         */
        public boolean hasTrackingLostCounter() {
            return (bitField0_ & 0x00000001) != 0;
        }

        /**
         * <pre>
         *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearTrackingLostCounter() {
            bitField0_ &= ~0x00000001;
            trackingLostCounter = 0;
            return this;
        }

        /**
         * <pre>
         *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @return the trackingLostCounter
         */
        public int getTrackingLostCounter() {
            return trackingLostCounter;
        }

        /**
         * <pre>
         *
         *  Count of tracking loss events since app startup.
         *  
         *  This counter increments each time the Quest's tracking system loses
         *  tracking after having established it. Tracking loss can occur due to:
         *  - Poor lighting conditions
         *  - Lack of visual features in environment
         *  - Rapid motion or acceleration
         *  - Occlusion of cameras
         *  - Hardware issues
         *  
         *  A high or rapidly increasing counter may indicate:
         *  - Environmental issues (lighting, features)
         *  - Quest mounting problems (vibration, obstruction)
         *  - Hardware degradation
         *  
         *  This metric helps assess tracking system reliability and can trigger
         *  alerts or fallback behaviors in robot code.
         * </pre>
         *
         * <code>optional int32 tracking_lost_counter = 1;</code>
         * @param value the trackingLostCounter to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setTrackingLostCounter(final int value) {
            bitField0_ |= 0x00000001;
            trackingLostCounter = value;
            return this;
        }

        /**
         * <pre>
         *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return whether the batteryPercent field is set
         */
        public boolean hasBatteryPercent() {
            return (bitField0_ & 0x00000002) != 0;
        }

        /**
         * <pre>
         *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearBatteryPercent() {
            bitField0_ &= ~0x00000002;
            batteryPercent = 0;
            return this;
        }

        /**
         * <pre>
         *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @return the batteryPercent
         */
        public int getBatteryPercent() {
            return batteryPercent;
        }

        /**
         * <pre>
         *
         *  Quest device battery level as a percentage (0-100).
         *  
         *  This provides the current battery charge level of the Quest headset,
         *  allowing external systems to:
         *  - Monitor power status during operation
         *  - Implement low-battery warnings or behaviors
         *  - Plan operation duration and charging needs
         *  - Trigger graceful shutdown procedures
         *  
         *  Battery Level Guidelines:
         *  - 100%: Fully charged
         *  - 50-100%: Normal operation
         *  - 20-50%: Consider charging soon
         *  - 10-20%: Low battery warning recommended
         *  - 0-10%: Critical - plan immediate shutdown/charging
         *  
         *  Note: Battery drain rate depends on:
         *  - Processing load (tracking complexity)
         *  - Display usage (if any)
         *  - Wireless communication activity
         *  - Environmental temperature
         * </pre>
         *
         * <code>optional int32 battery_percent = 3;</code>
         * @param value the batteryPercent to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setBatteryPercent(final int value) {
            bitField0_ |= 0x00000002;
            batteryPercent = value;
            return this;
        }

        /**
         * <pre>
         *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return whether the currentlyTracking field is set
         */
        public boolean hasCurrentlyTracking() {
            return (bitField0_ & 0x00000004) != 0;
        }

        /**
         * <pre>
         *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return this
         */
        public ProtobufQuestNavDeviceData clearCurrentlyTracking() {
            bitField0_ &= ~0x00000004;
            currentlyTracking = false;
            return this;
        }

        /**
         * <pre>
         *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @return the currentlyTracking
         */
        public boolean getCurrentlyTracking() {
            return currentlyTracking;
        }

        /**
         * <pre>
         *
         *  Current tracking status of the Quest device.
         *  
         *  true:  Quest is actively tracking and pose data is reliable
         *  false: Quest has lost tracking and pose data should not be trusted
         *  
         *  When tracking is lost:
         *  - Pose data becomes stale and unreliable
         *  - Robot should switch to alternative localization methods
         *  - Movement should be limited or stopped for safety
         *  
         *  Tracking can be recovered by:
         *  - Improving lighting conditions
         *  - Moving to area with more visual features
         *  - Reducing motion to allow system to re-initialize
         *  - Performing pose reset when tracking recovers
         *  
         *  External systems should monitor this field and implement appropriate
         *  fallback behaviors when tracking is lost.
         * </pre>
         *
         * <code>optional bool currently_tracking = 2;</code>
         * @param value the currentlyTracking to set
         * @return this
         */
        public ProtobufQuestNavDeviceData setCurrentlyTracking(final boolean value) {
            bitField0_ |= 0x00000004;
            currentlyTracking = value;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData copyFrom(final ProtobufQuestNavDeviceData other) {
            cachedSize = other.cachedSize;
            if ((bitField0_ | other.bitField0_) != 0) {
                bitField0_ = other.bitField0_;
                trackingLostCounter = other.trackingLostCounter;
                batteryPercent = other.batteryPercent;
                currentlyTracking = other.currentlyTracking;
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final ProtobufQuestNavDeviceData other) {
            if (other.isEmpty()) {
                return this;
            }
            cachedSize = -1;
            if (other.hasTrackingLostCounter()) {
                setTrackingLostCounter(other.trackingLostCounter);
            }
            if (other.hasBatteryPercent()) {
                setBatteryPercent(other.batteryPercent);
            }
            if (other.hasCurrentlyTracking()) {
                setCurrentlyTracking(other.currentlyTracking);
            }
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clear() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            trackingLostCounter = 0;
            batteryPercent = 0;
            currentlyTracking = false;
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clearQuick() {
            if (isEmpty()) {
                return this;
            }
            cachedSize = -1;
            bitField0_ = 0;
            return this;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            }
            if (!(o instanceof ProtobufQuestNavDeviceData)) {
                return false;
            }
            ProtobufQuestNavDeviceData other = (ProtobufQuestNavDeviceData) o;
            return bitField0_ == other.bitField0_
                && (!hasTrackingLostCounter() || trackingLostCounter == other.trackingLostCounter)
                && (!hasBatteryPercent() || batteryPercent == other.batteryPercent)
                && (!hasCurrentlyTracking() || currentlyTracking == other.currentlyTracking);
        }

        @Override
        public void writeTo(final ProtoSink output) throws IOException {
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeRawByte((byte) 8);
                output.writeInt32NoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeRawByte((byte) 24);
                output.writeInt32NoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeRawByte((byte) 16);
                output.writeBoolNoTag(currentlyTracking);
            }
        }

        @Override
        protected int computeSerializedSize() {
            int size = 0;
            if ((bitField0_ & 0x00000001) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                size += 1 + ProtoSink.computeInt32SizeNoTag(batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                size += 2;
            }
            return size;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public ProtobufQuestNavDeviceData mergeFrom(final ProtoSource input) throws IOException {
            // Enabled Fall-Through Optimization (QuickBuffers)
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 8: {
                        // trackingLostCounter
                        trackingLostCounter = input.readInt32();
                        bitField0_ |= 0x00000001;
                        tag = input.readTag();
                        if (tag != 24) {
                            break;
                        }
                    }
                    case 24: {
                        // batteryPercent
                        batteryPercent = input.readInt32();
                        bitField0_ |= 0x00000002;
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // currentlyTracking
                        currentlyTracking = input.readBool();
                        bitField0_ |= 0x00000004;
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        @Override
        public void writeTo(final JsonSink output) throws IOException {
            output.beginObject();
            if ((bitField0_ & 0x00000001) != 0) {
                output.writeInt32(FieldNames.trackingLostCounter, trackingLostCounter);
            }
            if ((bitField0_ & 0x00000002) != 0) {
                output.writeInt32(FieldNames.batteryPercent, batteryPercent);
            }
            if ((bitField0_ & 0x00000004) != 0) {
                output.writeBool(FieldNames.currentlyTracking, currentlyTracking);
            }
            output.endObject();
        }

        @Override
        public ProtobufQuestNavDeviceData mergeFrom(final JsonSource input) throws IOException {
            if (!input.beginObject()) {
                return this;
            }
            while (!input.isAtEnd()) {
                switch (input.readFieldHash()) {
                    case -1237870847:
                    case -2011984791: {
                        if (input.isAtField(FieldNames.trackingLostCounter)) {
                            if (!input.trySkipNullValue()) {
                                trackingLostCounter = input.readInt32();
                                bitField0_ |= 0x00000001;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case -2041653896:
                    case -1975165933: {
                        if (input.isAtField(FieldNames.batteryPercent)) {
                            if (!input.trySkipNullValue()) {
                                batteryPercent = input.readInt32();
                                bitField0_ |= 0x00000002;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    case 879013277:
                    case 106200592: {
                        if (input.isAtField(FieldNames.currentlyTracking)) {
                            if (!input.trySkipNullValue()) {
                                currentlyTracking = input.readBool();
                                bitField0_ |= 0x00000004;
                            }
                        } else {
                            input.skipUnknownField();
                        }
                        break;
                    }
                    default: {
                        input.skipUnknownField();
                        break;
                    }
                }
            }
            input.endObject();
            return this;
        }

        @Override
        public ProtobufQuestNavDeviceData clone() {
            return new ProtobufQuestNavDeviceData().copyFrom(this);
        }

        @Override
        public boolean isEmpty() {
            return ((bitField0_) == 0);
        }

        public static ProtobufQuestNavDeviceData parseFrom(final byte[] data) throws
                InvalidProtocolBufferException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), data).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final ProtoSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        public static ProtobufQuestNavDeviceData parseFrom(final JsonSource input) throws
                IOException {
            return ProtoMessage.mergeFrom(new ProtobufQuestNavDeviceData(), input).checkInitialized();
        }

        /**
         * @return factory for creating ProtobufQuestNavDeviceData messages
         */
        public static MessageFactory<ProtobufQuestNavDeviceData> getFactory() {
            return ProtobufQuestNavDeviceDataFactory.INSTANCE;
        }

        /**
         * @return this type's descriptor.
         */
        public static Descriptors.Descriptor getDescriptor() {
            return Data.questnav_protos_data_ProtobufQuestNavDeviceData_descriptor;
        }

        private enum ProtobufQuestNavDeviceDataFactory implements MessageFactory<ProtobufQuestNavDeviceData> {
            INSTANCE;

            @Override
            public ProtobufQuestNavDeviceData create() {
                return ProtobufQuestNavDeviceData.newInstance();
            }
        }

        /**
         * Contains name constants used for serializing JSON
         */
        static class FieldNames {
            static final FieldName trackingLostCounter = FieldName.forField("trackingLostCounter", "tracking_lost_counter");

            static final FieldName batteryPercent = FieldName.forField("batteryPercent", "battery_percent");

            static final FieldName currentlyTracking = FieldName.forField("currentlyTracking", "currently_tracking");
        }
    }
}